---
title: "01 Vectors and functions"
output: 
  html_document:
    theme: dark
    highlight: zenburn
---

```{css, echo=FALSE}
.dark-output {
  background-color: #5a5a5a;
  color: white;
}

.error-output {
  background-color: #cc9393;
  color: black;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, class.output = "dark-output", class.error = "error-output"
  )
```

## Hot Dog Data

In these exercises, we will work with vectors some more. We will also learn to use functions in R.
For these exercises, I have some actual data for you: It's from [Nathan's Hotdog Eating Contest](https://nathansfamous.com/hot-dog-eating-contest/hall-of-fame/).
This is not the full data - we only look at the data of a few contestants for this example.
We'll look at bigger data sets in a second.

This is a vector containing the number of hot dogs the contestants ate in 2018:

```{r}
hotdog_2018 <- 
  c(37, 43, 32, 27, 74, 14, 28, 25, 27, 19, 24)
```

And these are the results of the same contestants in 2019:

```{r}
hotdog_2019 <- 
  c(31, 50, 26, 29, 71, 14, 26.5, 23, 27, 18, 22)
```

Here is another vector that contains their names:

```{r}
hotdog_names <- 
  c("Miki Sudo", "Darron Breeden", "Juan Rodriguez", "Juan Neave", "Joey Chestnut",
    "Sophia DeVita", "Michelle Lesco", "Juliet Lee", "Derek Jacobs", "Larell Marie Mele",
    "Steve Hendry")
```

Here are their genders:

```{r}
hotdog_genders <- 
  c("male", "female", "male", "male", "male", "female", "female", "female", "male", "female",
    "male")
```

## Some simple functions

We will now use some functions to work with this data. For example, we can find out how many
contestants we have by asking how long one of our vectors is (they should all have the same
length). Unsurprisingly, we can do that with the function `length()`.

```{r}
length(hotdog_names)
```

A function in `R` always comes with a `()`.
It takes **arguments** (i.e. we put something in) and **returns** something (i.e. gives us a result).
Here, `hotdog_names` is the argument, and `11` is the return value or **output**.

Try out a few other functions. Here are some you could try:

1.1) `max()` gives you the maximum value in a vector. What do you think `min()` does? Use both on `hotdog_2018` and `hotdog_2019`.

1.2) Use `table()` on `hotdog_genders`. What do you get?

1.3) Use `mean()` and `sd()` on `hotdog_2018` and `hotdog_2019`. What do you get?

1.4) Use `summary()` on `hotdog_2018` and `hotdog_2019`. What is the difference to using `mean()` and `sd()`?

1.5) Use `head()` and `tail()` on either of the vectors. What do these functions do?

1.6) How many hotdogs were eaten in total in the year 2019? Use the function `sum()`.

## More arguments

Most functions take more than one argument.
For example, you can control the behaviour of `head()` and `tail()` with an additional argument.

2.1) Can you guess what the second argument in `head()` (and `tail()`) does?
What happens when you leave out the second argument?

```{r}
head(hotdog_names, 3)
head(hotdog_names, 1)
head(hotdog_names, 11)
head(hotdog_names)
```

2.2) What do you think will happen when the second argument is larger than the number of hot dog contestants (`r length(hotdog_names)`)? Try it.

We can see that arguments have a **position** in the function - for `head()`, the data belongs at the first position, and the number of elements we want to display comes second.
`head()` will be unhappy if we just switch the order around:

```{r error = TRUE}
head(10, hotdog_names)
```

The function expects some data at the first position, and an integer at the second position.
It is not "smart" it can't guess what we want.
(Also, in this case, guessing might be pretty easy, but in other cases, it's not so obvious what we actually want.)
However, you don't need to remember the order of arguments in a function (even though for simple functions, you automatically will at some point and use them that way).
You can also address arguments **by name**.
This way, `head()` understands what we want:

```{r}
head(n = 10, x = hotdog_names)
```

It is common in `R` that the data input of a function is simply called `x`.
That violates the rule to use self-explanatory names in good coding practice, but it is a convention that exists for ages.
We will discover more functions that take several arguments later.

In general, you can see which arguments a function takes by reading the documentation of that function.
Just type a question mark, and the the function name (without parentheses!), e.g. `?head`.
Often, the documentation is a bit overwhelming and gives you much more than you need.
In a lot of cases, you can just scroll down to the examples and see how the function should be used.

## Indexing

We will now learn how to access specific elements in a vector via so called **indexing**.
Let us bring up the names of the contestants again.
To get only the name of the third contestant, we do this:

```{r}
hotdog_names[3]
```

3.1) Can you find the name of the 5th contestant?

What if we wanted to find the names of the 3rd **and** the 5th contestant?
We can use another vector for indexing!

```{r}
hotdog_names[c(3, 5)]
```

It is important to use `c()` for this - `c()` puts 3 and 5 into the same vector.
If we write `[3, 5]`, we're trying to use two vectors at the same time (3 is the first, 5 is the second), and that won't work:

```{r error = TRUE}
hotdog_names[3, 5]
```

What if we want to see the first 3 contestants?

Bonus question: You already know one function which does this!

But there is another way.
Consider what this code does:

```{r}
1:10
```

3.2) Can you think of a way how we can modify and use this as an index to find the first three hot dog contestants?

We can use functions that return numbers for indexing.
So, anything that gives you a number can be used.
These examples do not make any sense, but show you how the principle works:

```{r}
hotdog_names[4-3]
```

```{r}
hotdog_names[min(1:10)]
```

One common situation is this: You want to get the last element in a vector, but you do not know how long it is.

3.3) How would you get the last name of the hot dog contestants using the `tail()` function we saw above?

3.4) Remember what `length(hotdog_names)` returns. How can you use that for indexing?

3.5) How would you get the name of the person who ate the most hot dogs in 2019? Use an index and the function `max()`! You will have to use two different vector here: `hotdog_names` and `hotdog_2019`.

There is more that can be done with indexing when we use logical comparisons.
Here is how this works: We have a vector called `numbers` that contains the number 1 - 4.

Bonus question: This vector could have been created differently (with less typing). How?

We also have an index (which we stored in a variable named `index` here) that is a logical vector.
We now apply this index to our vector `numbers`.
Examine the result.
What happened?

```{r}
numbers <- c(1, 2, 3, 4)
index <- c(TRUE, TRUE, FALSE, TRUE)
numbers[index]
```

Remember how we can create logical vectors.
Consider this code, for example - what does it do?

```{r}
numbers < 3
```

Let's apply this to our `numbers` vector:

```{r}
index <- numbers < 3
numbers[index]
```

What happened?

We can achieve the same thing without saving the index in a variable:

```{r}
numbers[numbers < 3]
```

It feels a little bit weird to use the same vector twice in one line.
But basically, what this code "translates" to is: Show me all of the elements in numbers (the first `numbers` in the code), where `numbers` is smaller than 3.
As humans, we would rather say something like: "Show me all elements in numbers smaller than 3."
For a computer, however, you need to explicitly say **what** should be smaller than 3.
Something like this will not work.
In fact, RStudio is already giving me a warning that something is wrong with my code.

```{r error = TRUE}
numbers[<3]
```

3.6) Can you write code that gives you all elements larger than 6 in the vector `1:10`?

How can we use indexing with logical vectors in a more useful way?
Let's get back to our hot dog examples.

3.7) Can you create a vector that is `TRUE` when the participant ate more hot dogs in 2019 than in 2018 and `FALSE` when s/he didn't? Remember that the results from 2018 are stored in `hotdog_2018` and the results from 2019 are stored in `hotdog_2019`.

We now would like to find out **which** participants improved from 2018 to 2019.
We can achieve this using indices.

3.8) Based on the previous examples, how would you get the names of the contestants who ate more hot dogs in 2019 than in 2018?

3.9) Can you find the name of the contestant who ate exactly the same number of hot dogs in 2018 and 2019?

3.10) Get the hot dog results **only for the men** in 2019 and save the results in a variable. (Think of a good name!) Do the same for the women's results in 2018.

3.11) Remember that you can combine logical comparisons using `&` and `|`. Can you find a way to get the name of the **woman** who ate the **most hot dogs in 2019** using `&` and `max()`? You will need to use several of the vectors in our environment for that!

**THIS IS A GIT PUSH CHECKPOINT!**
